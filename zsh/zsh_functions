_has() {
  return $( whence $1 >/dev/null )
}

mkc () {
  mkdir -p "$@" && cd "$@"
}

# Go Forward in Git history
# Usage: gofwd v1.2.7
gofwd() {
  git checkout `git rev-list --topo-order HEAD.."$*" | tail -1`
}

# Go Backward in Git history
# Usage: goback
alias goback='git checkout HEAD~'

finished () {
  push -t "Script Complete" "$@ has finished running"
}

# Java
javar () {
  filename=$1
  basename="${filename%.*}"
  javac $filename && java $basename
}

t() {
  # Defaults to 3 levels deep, do more with `t 5` or `t 1`
  # pass additional args after
  tree -I '.git|node_modules|bower_components|.DS_Store' --dirsfirst --filelimit 15 -L ${1:-3} -aC $2
}

docker-ip() {
  docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' "$@"
}

convert-to-mp3() {
  ffmpeg -i "$1" -f mp3 -acodec libmp3lame -ab 192000 -ar 44100 "$2"
}

tunnel-gcp() {
  if [ "$1" != "dk_prod" ] && [ "$1" != "dk_staging" ] && [ "$1" != "dk_qa" ]; then
    echo "Argument is invalid" >&2
    return 1
  fi

  socket_dir="$HOME/.ssh/sockets"
  socket_filename="db_socket_$1"
  socket_file="$socket_dir/$socket_filename"

  # Make sure the tunnel isn't already open by checking for the tmp file
  if [ -f "$socket_file" ]; then
    echo "Tunnel is already open, call close-tunnel-gcp $1 to close it"
    return 1
  fi

  # Create the tmp file directory if not exists
  mkdir -p $socket_dir

  # Set connection variables for the tunnel
  if [[ "$1" == "dk_prod" ]]; then
    db_addr=${DK_PROD_DB}
    ssh_addr=${DK_PROD_IP}
    tunnel_port=54321
    key_file=$HOME/.ssh/google_compute_engine

    echo "Tunneling Production DB on port ${tunnel_port} through ${ssh_addr}"
  elif [[ "$1" == "dk_staging" ]]; then
    db_addr=${DK_STAGING_DB}
    ssh_addr=${DK_STAGING_IP}
    tunnel_port=54322
    key_file=$HOME/.ssh/google_compute_engine

    echo "Tunneling Staging DB on port ${tunnel_port} through ${ssh_addr}"
  elif [[ "$1" == "dk_qa" ]]; then
    db_addr=${DK_QA_DB}
    ssh_addr=${DK_QA_IP}
    tunnel_port=54323
    key_file=$HOME/.ssh/google_compute_engine

    echo "Tunneling QA DB on port ${tunnel_port} through ${ssh_addr}"
  fi

  ssh -M -S $socket_file -fnNT -L $tunnel_port:$db_addr $ssh_addr -i $key_file

  unset db_addr
  unset ssh_addr
  unset tunnel_port
  unset key_file
  unset socket_dir
  unset socket_filename
  unset socket_file
}

close-tunnel-gcp() {
  if [ "$1" != "all" ] && [ "$1" != "dk_prod" ] && [ "$1" != "dk_staging" ] && [ "$1" != "dk_qa" ]; then
    echo "Argument is invalid" >&2
    return 1
  fi

  socket_dir="$HOME/.ssh/sockets"

  if [ "$1" == "all" ]; then
    for filename in $(ls $socket_dir); do
      socket_file="$socket_dir/$filename"
      echo "Closing $filename"
      ssh -S $socket_file -O exit 0
    done
  else
    socket_filename="db_socket_$1"
    socket_file="$socket_dir/$socket_filename"

    ssh -S $socket_file -O exit 0
  fi

  unset socket_dir
  unset socket_filename
  unset socket_file
}

# Executes the provided command in the first pod matching the given search term.
# Multiple words must be quoted.
#
# e.g. `kube_exec rails-web bash` or `kube_exec debug "rails c"`
kube_exec() {
  exec_pod=`kubectl get pods | grep ${1} | cut -d" " -f 1 | head -1`
  echo "Executing ${2} in ${exec_pod} at `kubectl config view -o=jsonpath='{.current-context}'`"
  echo ""

  kubectl exec $exec_pod -c rails -it $2
  unset exec_pod
}

kube_debug_shell() {
  kube_exec debug bash
}

# extract any time of compressed file
extract() {
  echo Extracting $1 ...
  if [ -f $1 ] ; then
    case $1 in
      *.tar.bz2)   tar xjf $1  ;;
      *.tar.gz)    tar xzf $1  ;;
      *.bz2)       bunzip2 $1  ;;
      *.rar)       rar x $1    ;;
      *.gz)        gunzip $1   ;;
      *.tar)       tar xf $1   ;;
      *.tbz2)      tar xjf $1  ;;
      *.tgz)       tar xzf $1  ;;
      *.zip)       unzip $1   ;;
      *.Z)         uncompress $1  ;;
      *.7z)        7z x $1  ;;
      *)        echo "'$1' cannot be extracted via extract()" ;;
    esac
  else
      echo "'$1' is not a valid file"
  fi
}
